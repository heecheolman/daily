- 객체지향 프로그래밍
  - 객체지향은 객체를 지향하는 것
  - 우리는 어떻게 작성하고 있었나?
    1. 어떤 클래스가 필요한지 고민
    2. 클래스에 어떤 속성과 메서드가 필요한지 고민
  - 이렇게 작성하면 객체지향의 본질과 거리가 멀어진다.
  - 객체에 초점을 둬야한다.
  - 객체에 초점을 두기위해 집중해야 하는 것 두가지가 있다.
    1. 어떤 객체들이 필요할까?
       - 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한 것
       - 따라서, 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 갖는지 결정해야한다.
    2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 본다.
       - 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.
       - 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 **타입** 으로 분류하고 **타입을 기반으로 클래스를 구현**
- 도메인의 구조를 따르는 프로그램 구조
  - 도메인(Domain)이란 무엇인가?
    - 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
  - 객체지향 프로그래밍이 강력한 이유
    - **요구사항과 프로그램을 "객체"라는 동일한 관점에서 바라볼 수 있기 때문에 도메인을 구성하는 개념들이 프로그램의 객체와 클래스로 연결될 수 있다.**
  - 일반적으로 클래스의 이름은 대응되는 도메인의 이름과 동일하거나 비슷해야한다.
  - 클래스 사이의 관계도 최대한 도메인 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다.
- 클래스 구현하기
  - 클래스를 작성할 때 내부와 외부를 구분해서 작성해야 한다.
  - 객체는 상태(State)와 행동(Behavior)를 가지고 있고 이를 하나로 묶는 것을 '캡슐화' 라고 한다.
  - 객체지향 언어에서 외부의 접근제한을 위해 접근 수정자(Access Modifier)를 제공한다.
    - private, protected, public
  - 왜 접근제어를 할까?
    - 객체는 스스로 행동할 수 있는 자율적인 존재가 되어야하기 때문에 외부에서는 객체가 어떤 상태에 있는지 혹은 상태를 직접 수정하려는 행위는 안된다.
    - 외부는 객체에 원하는 것을 '요청' 하여 객체 스스로가 결정하도록 기다려야한다.
    - 외부로 노출 시킬 부분을 퍼블릭 인터페이스(Public Interface), 내부에서만 접근 가능한 부분을 구현(Implementation)이라고 한다.
    - 인터페이스와 구현의 분리는 객체지향의 핵심원칙이다.
    - **즉, 인터페이스와 구현을 나눔으로서 객체들간에 적절한 의존성을 갖게한다.**
  - 프로그래머의 입장에서 인터페이스와 구현의 분리는 무엇일까?
    - 외부로 노출시킬 인터페이스만 변경하지 않는다면 내부 구현은 외부로 노출되지 않기 때문에 구현을 자유롭게 변경할 수 있다.
      - 예를들어, 클라이언트가 서버에 API 를 요청하여 응답을 받아보는 것과 유사하다. 서버는 정해진 스펙에 따라 응답값만 보내주면 되고 내부 구현은 숨기면 된다. 클라이언트는 서버가 내부적으로 어떻게 구현되어 있는지 알 필요 없다.
      - 더 쉽게 설명하자면 휴대폰 충전을 위해 전기를 얻어야한다. 어댑터를 콘센트에 꽂아서 전기만 얻으면 된다. 내부적으로 전기가 어떻게 전달되고 있는지 알 필요는 없다.
- 협력하는 객체들의 공동체
  - 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것
  - 따라서, 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하는 것이 좋다.
  - 그 개념이 비록 하나의 값만 가리키더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸음
  - 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용을 '협력(Collaboration)' 이라고 한다.
  - 객체지향 프로그램을 작성할 때 먼저 협력의 관점에서 어떤 객체가 필요한지를 결정하고, 객체들의 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.
- 협력
  - 객체의 내부 상태는 외부에서 접근하지 못하도록 숨겨야 한다.
  - 대신, 객체의 퍼블릭 인터페이스를 이용해 외부에서 접근할 수 있는 방법을 제공한다.
  - 이렇게되면 객체는 다른객체에 '요청(Request)'을 하고 요청을 받은 객체는 '응답(Response)'해준다.
  - 메시지(Message)와 메서드(Method)
    - 객체는 다른 객체에 접근할 때 퍼블릭 인터페이스를 호출하게 되는데 이를 '메시지 전송' 이라고 한다.
    - 호출당한 객체는 적절한 내부 함수를 호출하여 처리를 하는데 이를 처리하는 함수를 '메서드'라고 한다.
    - 메시지와 메서드를 명확하게 구분하면 이후에 다룰 다형성(Polymorphism)이라는 개념의 출발이 된다.
- 추상화(abstraction)를 기반으로 한 상속(inheritance) 와 다형성
  - _상황 예: 할인정책에는 '금액 할인 정책'과 '비율 할인 정책'이 존재_
  - '금액 할인 정책'과 '비율 할인 정책'은 대부분 코드가 유사하고 할인 요금을 계산하는 방식이 조금 다를 뿐이다.
  - 때문에 중복 코드를 제거하기 위해 부모 클래스를 두고 이를 상속받게 한다.
  - 부모 클래스는 실제로 인스턴스로 생성할 것이 아니기 때문에 '추상 클래스(abstract class)' 로 구현한다.
  - '요금계산' 이라는 메서드를 부모클래스의 추상메서드로 지정해놓고, '금액 할인 정책'과 '비율 할인 정책'이 메서드를 상속받아 직접 구현하게 하여 위임한다.
  - 부모클래스에서 공통적인 알고리즘을 잡고 중간에 필요한 처리를 자식클래스에 위임하는 디자인 패턴을 'TEMPLATE METHOD(템플릿 메서드)' 패턴이라고 부른다.
- 오버라이딩(Overriding)과 오버로딩(Overloading)
  - 오버라이딩은 부모클래스에 정의된 같은 이름, 같은 파라미터 목록을 가진 메서드를 자식 클래스에서 재정의 하는것을 말한다.
  - 오버로딩은 메서드의 이름은 같지만 파라미터의 개수, 파라미터의 타입이 다르다면 각 타입 및 개수에 따라 적절한 메서드를 선택해 호출되는 것을 말한다.
- 컴파일 시간 의존성과 실행 시간 의존성
  - 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 '의존성이 있다' 라고 말한다.
  - 코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있다. 다시말해, 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않을 수 있다.
  - 코드의 의존성과 실행 시점의 의존성이 다르면 다를수록 코드를 이해하기 어려워진다. 왜냐면 코드를 이해하기 위해서는 객체를 생성하고 연결하는 부분을 찾아야 하기 때문이다.
  - 반면, 코드의 의존성과 실행 시점의 의존성이 다르면 다를 수록 유연해지고 확장 가능해진다.
  - 이러한 이유로 의존성의 양면성은 트레이드오프의 산물이다.
  - 즉, 설계가 유연해질수록 코드를 이해하고 디버깅하기는 어려워진다. 반면에 유연성을 억제하면 코드를 이해하고 디버깅하기는 쉬워지지만 재사용성과 확장 가능성은 낮아진다는 사실이다.
- 차이에 의한 프로그래밍
  - 상속은 코드를 재사용하기 위해 가장 널리 사용되는 방법이다.
  - 상속을 이용하면 기존 클래스가 가지고 있는것을 새로운 클래스에 포함시킬 수 있다.
  - 부모 클래스의 구현은 공유하면서, 자식클래스에서 다르게 구현하고 싶다면 오버라이딩하여 수정할 수 있다.
  - 이처럼 부모클래스와 다른 부분만 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법을 '차이에 의한 프로그래밍(programming by difference)' 라고 부른다.
